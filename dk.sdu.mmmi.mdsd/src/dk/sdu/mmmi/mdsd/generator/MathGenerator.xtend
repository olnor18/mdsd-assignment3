/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.MathExp
import java.util.Map
import java.util.HashMap
import dk.sdu.mmmi.mdsd.math.*
import java.util.Collections
import java.util.List
import java.util.Comparator
import java.util.ArrayList
import javax.swing.JOptionPane
import org.eclipse.xtext.EcoreUtil2

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	val package_name = "math_expression";
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val maths = resource.allContents.filter(Math);
		maths.forEach[math |
			val code = generateClass(math.name, math.lines, math.externals)
			//println(code)
			fsa.generateFile(package_name+ "/" +math.name+".java", code)
		]
		
	}
	
	def generateClass(String name, List<MathExp> vars, List<External> externals) {
		var orderedVariables = orderVariables(vars);
		return 
		'''
		//Generated by xtext. Generator by olnor18
		package «package_name»;
		public class «name» {
			«FOR variable : vars»
			public int «variable.value.name»;
			«ENDFOR»
			
			«IF externals.size != 0»
			private External external;
			
			public «name»(External external) {
				this.external = external;
			}
			«ENDIF»
			
			public void compute() {
				«FOR variable : orderedVariables»
				«variable.value.name» = «variables.get(variable.value.name)»;
				«ENDFOR»
			}
		
			«IF externals.size != 0»
			public interface External {
				«FOR external : externals»
				public int «external.name»(«external.generateInterfaceParameter()»);
				«ENDFOR»		
			}
			«ENDIF»
		}
		'''
	}
	
	static Map<String, String> variables = new HashMap();
	static List<MathExp> linesToBeProcessed = new ArrayList();
	
	def orderVariables(List<MathExp> exps) {
		variables = new HashMap();
		linesToBeProcessed=new ArrayList(exps)
		val List<MathExp> order = new ArrayList();
		exps.forEach[line|
				line.compute(order)
		]
		return order
	}
	
	def static void compute(MathExp math, List<MathExp> order) {
		if (linesToBeProcessed.contains(math)){
			variables.put(math.value.name, math.value.exp.computeExp(variables, order))
			order.add(math)
			linesToBeProcessed.remove(math)
		}
	}
	
	def static String computeExp(Expression exp, Map<String, String> vars, List<MathExp> order) {
		switch exp {
			Subtraction: exp.left.computeExp(vars, order)+" - "+exp.right.computeExp(vars, order)
			Parenthesis: "(" + exp.inner.computeExp(vars, order) + ")"
			Addition: exp.left.computeExp(vars, order)+" + "+exp.right.computeExp(vars, order)
			Multiplication: exp.left.computeExp(vars, order)+ " * " +exp.right.computeExp(vars, order)
			Division: exp.left.computeExp(vars, order)+ " / " +exp.right.computeExp(vars, order)
			Number: exp.value.toString()
			VarUse: {
					if (exp.ref.name === null) {
						throw new Exception("The calculation references a variable, that points to null. This is likely a scoping issue")
					}
					if (exp.ref.eContainer instanceof Let){
						return "("+exp.ref.exp.computeExp(vars, order)+")"
					}
					if(vars.containsKey(exp.ref.name)){
						return exp.ref.name
					} else {
						for (MathExp line : new ArrayList(linesToBeProcessed)){
							if (line.value.name == exp.ref.name){
								line.compute(order)
								if(variables.containsKey(exp.ref.name)){
									val calculatedValue = variables.get(exp.ref.name)
									vars.put(exp.ref.name, calculatedValue)
									return exp.ref.name
								} else {
									throw new Exception("Adhoc calculation of " + exp.ref.name + " did not add a value to the global variable")
								}
							}
						}
						throw new Exception("The calculation references a variable, that is not in the list of MathExp")
					}
				}
			Let: {
				//val localVars = new HashMap(vars);
				//val letVal = exp.value.exp.computeExp(localVars, order)
				//localVars.put(exp.value.name, letVal)
				//val value = exp.exp.computeExp(localVars, order)
				//val assignment = EcoreUtil2.getContainerOfType(exp.eContainer, Assignment)
				//return '''0; { int «exp.value.name» = «letVal»; «assignment.name» = «value»}'''
				return exp.exp.computeExp(vars, order)
			}
			ExternalUse: {
				return
				'''this.external.«exp.ref.name»(«FOR param: exp.parameters SEPARATOR ', '»«param.computeExp(vars, order)»«ENDFOR»)'''
			}
		}
	}
	
	def generateInterfaceParameter(External external){
		return 
		'''«FOR name : external.argNames SEPARATOR ', '»int «name»«ENDFOR»'''
	}
	
	def argNames(External external){
		val ArrayList<String> value = new ArrayList<String>()
		var i = 0;
		for (type : external.argsType){
			value.add((('n'.charAt(0)+i) as char).toString())
			i -= 1;
		}
		return value;
	}
}
