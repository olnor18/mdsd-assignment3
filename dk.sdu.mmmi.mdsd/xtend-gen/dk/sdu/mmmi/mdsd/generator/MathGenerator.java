/**
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import dk.sdu.mmmi.mdsd.math.Addition;
import dk.sdu.mmmi.mdsd.math.Division;
import dk.sdu.mmmi.mdsd.math.Expression;
import dk.sdu.mmmi.mdsd.math.External;
import dk.sdu.mmmi.mdsd.math.ExternalUse;
import dk.sdu.mmmi.mdsd.math.Let;
import dk.sdu.mmmi.mdsd.math.MathExp;
import dk.sdu.mmmi.mdsd.math.Multiplication;
import dk.sdu.mmmi.mdsd.math.Parenthesis;
import dk.sdu.mmmi.mdsd.math.Subtraction;
import dk.sdu.mmmi.mdsd.math.VarUse;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MathGenerator extends AbstractGenerator {
  private final String package_name = "math_expression";
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Iterator<dk.sdu.mmmi.mdsd.math.Math> maths = Iterators.<dk.sdu.mmmi.mdsd.math.Math>filter(resource.getAllContents(), dk.sdu.mmmi.mdsd.math.Math.class);
    final Procedure1<dk.sdu.mmmi.mdsd.math.Math> _function = (dk.sdu.mmmi.mdsd.math.Math math) -> {
      final String code = this.generateClass(math.getName(), math.getLines(), math.getExternals());
      String _name = math.getName();
      String _plus = ((this.package_name + "/") + _name);
      String _plus_1 = (_plus + ".java");
      fsa.generateFile(_plus_1, code);
    };
    IteratorExtensions.<dk.sdu.mmmi.mdsd.math.Math>forEach(maths, _function);
  }
  
  public String generateClass(final String name, final List<MathExp> vars, final List<External> externals) {
    List<MathExp> orderedVariables = this.orderVariables(vars);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//Generated by xtext. Generator by olnor18");
    _builder.newLine();
    _builder.append("package ");
    _builder.append(this.package_name);
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("public class ");
    _builder.append(name);
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    {
      for(final MathExp variable : vars) {
        _builder.append("\t");
        _builder.append("public int ");
        String _name = variable.getValue().getName();
        _builder.append(_name, "\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    {
      int _size = externals.size();
      boolean _notEquals = (_size != 0);
      if (_notEquals) {
        _builder.append("\t");
        _builder.append("private External external;");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("public ");
        _builder.append(name, "\t");
        _builder.append("(External external) {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("this.external = external;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void compute() {");
    _builder.newLine();
    {
      for(final MathExp variable_1 : orderedVariables) {
        _builder.append("\t\t");
        String _name_1 = variable_1.getValue().getName();
        _builder.append(_name_1, "\t\t");
        _builder.append(" = ");
        String _get = MathGenerator.variables.get(variable_1.getValue().getName());
        _builder.append(_get, "\t\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    {
      int _size_1 = externals.size();
      boolean _notEquals_1 = (_size_1 != 0);
      if (_notEquals_1) {
        _builder.append("\t");
        _builder.append("public interface External {");
        _builder.newLine();
        {
          for(final External external : externals) {
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("public int ");
            String _name_2 = external.getName();
            _builder.append(_name_2, "\t\t");
            _builder.append("(");
            String _generateInterfaceParameter = this.generateInterfaceParameter(external);
            _builder.append(_generateInterfaceParameter, "\t\t");
            _builder.append(");");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder.toString();
  }
  
  private static Map<String, String> variables = new HashMap<String, String>();
  
  private static List<MathExp> linesToBeProcessed = new ArrayList<MathExp>();
  
  public List<MathExp> orderVariables(final List<MathExp> exps) {
    HashMap<String, String> _hashMap = new HashMap<String, String>();
    MathGenerator.variables = _hashMap;
    ArrayList<MathExp> _arrayList = new ArrayList<MathExp>(exps);
    MathGenerator.linesToBeProcessed = _arrayList;
    final List<MathExp> order = new ArrayList<MathExp>();
    final Consumer<MathExp> _function = (MathExp line) -> {
      MathGenerator.compute(line, order);
    };
    exps.forEach(_function);
    return order;
  }
  
  public static void compute(final MathExp math, final List<MathExp> order) {
    boolean _contains = MathGenerator.linesToBeProcessed.contains(math);
    if (_contains) {
      MathGenerator.variables.put(math.getValue().getName(), MathGenerator.computeExp(math.getValue().getExp(), MathGenerator.variables, order));
      order.add(math);
      MathGenerator.linesToBeProcessed.remove(math);
    }
  }
  
  public static String computeExp(final Expression exp, final Map<String, String> vars, final List<MathExp> order) {
    try {
      String _switchResult = null;
      boolean _matched = false;
      if (exp instanceof Subtraction) {
        _matched=true;
        String _computeExp = MathGenerator.computeExp(((Subtraction)exp).getLeft(), vars, order);
        String _plus = (_computeExp + " - ");
        String _computeExp_1 = MathGenerator.computeExp(((Subtraction)exp).getRight(), vars, order);
        _switchResult = (_plus + _computeExp_1);
      }
      if (!_matched) {
        if (exp instanceof Parenthesis) {
          _matched=true;
          String _computeExp = MathGenerator.computeExp(((Parenthesis)exp).getInner(), vars, order);
          String _plus = ("(" + _computeExp);
          _switchResult = (_plus + ")");
        }
      }
      if (!_matched) {
        if (exp instanceof Addition) {
          _matched=true;
          String _computeExp = MathGenerator.computeExp(((Addition)exp).getLeft(), vars, order);
          String _plus = (_computeExp + " + ");
          String _computeExp_1 = MathGenerator.computeExp(((Addition)exp).getRight(), vars, order);
          _switchResult = (_plus + _computeExp_1);
        }
      }
      if (!_matched) {
        if (exp instanceof Multiplication) {
          _matched=true;
          String _computeExp = MathGenerator.computeExp(((Multiplication)exp).getLeft(), vars, order);
          String _plus = (_computeExp + " * ");
          String _computeExp_1 = MathGenerator.computeExp(((Multiplication)exp).getRight(), vars, order);
          _switchResult = (_plus + _computeExp_1);
        }
      }
      if (!_matched) {
        if (exp instanceof Division) {
          _matched=true;
          String _computeExp = MathGenerator.computeExp(((Division)exp).getLeft(), vars, order);
          String _plus = (_computeExp + " / ");
          String _computeExp_1 = MathGenerator.computeExp(((Division)exp).getRight(), vars, order);
          _switchResult = (_plus + _computeExp_1);
        }
      }
      if (!_matched) {
        if (exp instanceof dk.sdu.mmmi.mdsd.math.Number) {
          _matched=true;
          _switchResult = Integer.valueOf(((dk.sdu.mmmi.mdsd.math.Number)exp).getValue()).toString();
        }
      }
      if (!_matched) {
        if (exp instanceof VarUse) {
          _matched=true;
          String _name = ((VarUse)exp).getRef().getName();
          boolean _tripleEquals = (_name == null);
          if (_tripleEquals) {
            throw new Exception("The calculation references a variable, that points to null. This is likely a scoping issue");
          }
          EObject _eContainer = ((VarUse)exp).getRef().eContainer();
          if ((_eContainer instanceof Let)) {
            String _computeExp = MathGenerator.computeExp(((VarUse)exp).getRef().getExp(), vars, order);
            String _plus = ("(" + _computeExp);
            return (_plus + ")");
          }
          boolean _containsKey = vars.containsKey(((VarUse)exp).getRef().getName());
          if (_containsKey) {
            return ((VarUse)exp).getRef().getName();
          } else {
            ArrayList<MathExp> _arrayList = new ArrayList<MathExp>(MathGenerator.linesToBeProcessed);
            for (final MathExp line : _arrayList) {
              String _name_1 = line.getValue().getName();
              String _name_2 = ((VarUse)exp).getRef().getName();
              boolean _equals = Objects.equal(_name_1, _name_2);
              if (_equals) {
                MathGenerator.compute(line, order);
                boolean _containsKey_1 = MathGenerator.variables.containsKey(((VarUse)exp).getRef().getName());
                if (_containsKey_1) {
                  final String calculatedValue = MathGenerator.variables.get(((VarUse)exp).getRef().getName());
                  vars.put(((VarUse)exp).getRef().getName(), calculatedValue);
                  return ((VarUse)exp).getRef().getName();
                } else {
                  String _name_3 = ((VarUse)exp).getRef().getName();
                  String _plus_1 = ("Adhoc calculation of " + _name_3);
                  String _plus_2 = (_plus_1 + " did not add a value to the global variable");
                  throw new Exception(_plus_2);
                }
              }
            }
            throw new Exception("The calculation references a variable, that is not in the list of MathExp");
          }
        }
      }
      if (!_matched) {
        if (exp instanceof Let) {
          _matched=true;
          return MathGenerator.computeExp(((Let)exp).getExp(), vars, order);
        }
      }
      if (!_matched) {
        if (exp instanceof ExternalUse) {
          _matched=true;
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("this.external.");
          String _name = ((ExternalUse)exp).getRef().getName();
          _builder.append(_name);
          _builder.append("(");
          {
            EList<Expression> _parameters = ((ExternalUse)exp).getParameters();
            boolean _hasElements = false;
            for(final Expression param : _parameters) {
              if (!_hasElements) {
                _hasElements = true;
              } else {
                _builder.appendImmediate(", ", "");
              }
              String _computeExp = MathGenerator.computeExp(param, vars, order);
              _builder.append(_computeExp);
            }
          }
          _builder.append(")");
          return _builder.toString();
        }
      }
      return _switchResult;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public String generateInterfaceParameter(final External external) {
    StringConcatenation _builder = new StringConcatenation();
    {
      ArrayList<String> _argNames = this.argNames(external);
      boolean _hasElements = false;
      for(final String name : _argNames) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(", ", "");
        }
        _builder.append("int ");
        _builder.append(name);
      }
    }
    return _builder.toString();
  }
  
  public ArrayList<String> argNames(final External external) {
    final ArrayList<String> value = new ArrayList<String>();
    int i = 0;
    EList<String> _argsType = external.getArgsType();
    for (final String type : _argsType) {
      {
        char _charAt = "n".charAt(0);
        int _plus = (_charAt + i);
        value.add(Character.valueOf(((char) _plus)).toString());
        int _i = i;
        i = (_i - 1);
      }
    }
    return value;
  }
}
