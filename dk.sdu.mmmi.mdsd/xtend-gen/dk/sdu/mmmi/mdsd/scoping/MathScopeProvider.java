/**
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.scoping;

import dk.sdu.mmmi.mdsd.math.Assignment;
import dk.sdu.mmmi.mdsd.math.Let;
import dk.sdu.mmmi.mdsd.math.MathExp;
import dk.sdu.mmmi.mdsd.math.VarUse;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class MathScopeProvider extends AbstractMathScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope scope = super.getScope(context, reference);
    if ((context instanceof VarUse)) {
      final EObject rootElement = EcoreUtil2.getRootContainer(context);
      final List<Assignment> candidates = EcoreUtil2.<Assignment>getAllContentsOfType(rootElement, Assignment.class);
      final Function1<Assignment, Boolean> _function = (Assignment a) -> {
        EObject _eContainer = a.eContainer();
        return Boolean.valueOf((_eContainer instanceof MathExp));
      };
      final Function1<Assignment, Boolean> _function_1 = (Assignment a) -> {
        EObject _eContainer = a.eContainer();
        MathExp _containerOfType = EcoreUtil2.<MathExp>getContainerOfType(context, MathExp.class);
        return Boolean.valueOf((_eContainer != _containerOfType));
      };
      final List<Assignment> validCandidates = IterableExtensions.<Assignment>toList(IterableExtensions.<Assignment>filter(IterableExtensions.<Assignment>filter(candidates, _function), _function_1));
      final Let let = EcoreUtil2.<Let>getContainerOfType(context, Let.class);
      if ((let != null)) {
        this.addLets(validCandidates, let, candidates);
      }
      return Scopes.scopeFor(validCandidates);
    }
    return scope;
  }
  
  public void addLets(final List<Assignment> validCandidates, final Let let, final List<Assignment> candidates) {
    final Function1<Assignment, Boolean> _function = (Assignment a) -> {
      EObject _eContainer = a.eContainer();
      return Boolean.valueOf((_eContainer == let));
    };
    validCandidates.add(IterableExtensions.<Assignment>findFirst(candidates, _function));
    final Let newLet = EcoreUtil2.<Let>getContainerOfType(let.eContainer(), Let.class);
    if ((newLet != null)) {
      this.addLets(validCandidates, newLet, candidates);
    }
  }
}
