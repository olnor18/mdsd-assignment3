/**
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.scoping;

import com.google.common.base.Objects;
import dk.sdu.mmmi.mdsd.math.Assignment;
import dk.sdu.mmmi.mdsd.math.Let;
import dk.sdu.mmmi.mdsd.math.MathExp;
import dk.sdu.mmmi.mdsd.math.VarUse;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class MathScopeProvider extends AbstractMathScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope scope = super.getScope(context, reference);
    if ((context instanceof VarUse)) {
      final EObject rootElement = EcoreUtil2.getRootContainer(context);
      final List<Assignment> candidates = EcoreUtil2.<Assignment>getAllContentsOfType(rootElement, Assignment.class);
      final Function1<Assignment, Boolean> _function = (Assignment a) -> {
        EObject _eContainer = a.eContainer();
        return Boolean.valueOf((_eContainer instanceof MathExp));
      };
      final Function1<Assignment, Boolean> _function_1 = (Assignment a) -> {
        EObject _eContainer = a.eContainer();
        MathExp _containerOfType = EcoreUtil2.<MathExp>getContainerOfType(context, MathExp.class);
        return Boolean.valueOf((_eContainer != _containerOfType));
      };
      final List<Assignment> validCandidates = IterableExtensions.<Assignment>toList(IterableExtensions.<Assignment>filter(IterableExtensions.<Assignment>filter(candidates, _function), _function_1));
      Let let = EcoreUtil2.<Let>getContainerOfType(context, Let.class);
      if (((let != null) && (IterableExtensions.<VarUse>toList(IterableExtensions.<VarUse>filter(EcoreUtil2.<VarUse>getAllContentsOfType(let.getValue().getExp(), VarUse.class), ((Function1<VarUse, Boolean>) (VarUse varuse) -> {
        return Boolean.valueOf((varuse == context));
      }))).size() > 0))) {
        let = EcoreUtil2.<Let>getContainerOfType(let.eContainer(), Let.class);
      }
      if ((let != null)) {
        this.addLets(validCandidates, context, let, candidates);
      }
      return Scopes.scopeFor(validCandidates);
    }
    return scope;
  }
  
  public void addLets(final List<Assignment> validCandidates, final EObject context, final Let let, final List<Assignment> candidates) {
    final Function1<Assignment, Boolean> _function = (Assignment a) -> {
      return Boolean.valueOf(((a.getName() == let.getValue().getName()) && (a.eContainer() instanceof Let)));
    };
    int _size = IterableExtensions.size(IterableExtensions.<Assignment>filter(validCandidates, _function));
    boolean _equals = (_size == 0);
    if (_equals) {
      final Function1<Assignment, Boolean> _function_1 = (Assignment a) -> {
        EObject _eContainer = a.eContainer();
        return Boolean.valueOf((_eContainer == let));
      };
      validCandidates.add(IterableExtensions.<Assignment>findFirst(candidates, _function_1));
      final Function1<Assignment, Boolean> _function_2 = (Assignment a) -> {
        EObject _eContainer = a.eContainer();
        return Boolean.valueOf((_eContainer instanceof MathExp));
      };
      final Function1<Assignment, Boolean> _function_3 = (Assignment a) -> {
        String _name = a.getName();
        String _name_1 = let.getValue().getName();
        return Boolean.valueOf(Objects.equal(_name, _name_1));
      };
      final Assignment shadowedMathExp = IterableExtensions.<Assignment>findFirst(IterableExtensions.<Assignment>filter(validCandidates, _function_2), _function_3);
      validCandidates.remove(shadowedMathExp);
    }
    final Let newLet = EcoreUtil2.<Let>getContainerOfType(let.eContainer(), Let.class);
    if ((newLet != null)) {
      this.addLets(validCandidates, context, newLet, candidates);
    }
  }
}
