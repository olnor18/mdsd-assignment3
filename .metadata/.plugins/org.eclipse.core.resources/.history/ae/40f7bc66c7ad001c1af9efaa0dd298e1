/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.serializer;

import com.google.inject.Inject;
import dk.sdu.mmmi.mdsd.math.Addition;
import dk.sdu.mmmi.mdsd.math.Division;
import dk.sdu.mmmi.mdsd.math.Expression;
import dk.sdu.mmmi.mdsd.math.Let;
import dk.sdu.mmmi.mdsd.math.MathExp;
import dk.sdu.mmmi.mdsd.math.MathPackage;
import dk.sdu.mmmi.mdsd.math.Multiplication;
import dk.sdu.mmmi.mdsd.math.Subtractio;
import dk.sdu.mmmi.mdsd.services.MathGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MathSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MathGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MathPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MathPackage.ADDITION:
				sequence_AdditionExp(context, (Addition) semanticObject); 
				return; 
			case MathPackage.DIVISION:
				sequence_DivisionExp(context, (Division) semanticObject); 
				return; 
			case MathPackage.EXPRESSION:
				if (rule == grammarAccess.getNumberRule()) {
					sequence_Number(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpRule()
						|| rule == grammarAccess.getSubtractionExpRule()
						|| action == grammarAccess.getSubtractionExpAccess().getSubtractioLeftAction_1_1()
						|| rule == grammarAccess.getAdditionExpRule()
						|| action == grammarAccess.getAdditionExpAccess().getAdditionLeftAction_1_1()
						|| rule == grammarAccess.getDivisionExpRule()
						|| action == grammarAccess.getDivisionExpAccess().getDivisionLeftAction_1_1()
						|| rule == grammarAccess.getMultiplicationExpRule()
						|| action == grammarAccess.getMultiplicationExpAccess().getMultiplicationLeftAction_1_1()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getParenthesisRule()) {
					sequence_Number_VariableUse(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableUseRule()) {
					sequence_VariableUse(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case MathPackage.LET:
				sequence_Let(context, (Let) semanticObject); 
				return; 
			case MathPackage.MATH_EXP:
				sequence_MathExp(context, (MathExp) semanticObject); 
				return; 
			case MathPackage.MULTIPLICATION:
				sequence_MultiplicationExp(context, (Multiplication) semanticObject); 
				return; 
			case MathPackage.SUBTRACTIO:
				sequence_SubtractionExp(context, (Subtractio) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Exp returns Addition
	 *     SubtractionExp returns Addition
	 *     SubtractionExp.Subtractio_1_1 returns Addition
	 *     AdditionExp returns Addition
	 *     AdditionExp.Addition_1_1 returns Addition
	 *     DivisionExp returns Addition
	 *     DivisionExp.Division_1_1 returns Addition
	 *     MultiplicationExp returns Addition
	 *     MultiplicationExp.Multiplication_1_1 returns Addition
	 *     Primary returns Addition
	 *     Parenthesis returns Addition
	 *
	 * Constraint:
	 *     (left=AdditionExp_Addition_1_1 right=DivisionExp)
	 */
	protected void sequence_AdditionExp(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionExpAccess().getAdditionLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionExpAccess().getRightDivisionExpParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Division
	 *     SubtractionExp returns Division
	 *     SubtractionExp.Subtractio_1_1 returns Division
	 *     AdditionExp returns Division
	 *     AdditionExp.Addition_1_1 returns Division
	 *     DivisionExp returns Division
	 *     DivisionExp.Division_1_1 returns Division
	 *     MultiplicationExp returns Division
	 *     MultiplicationExp.Multiplication_1_1 returns Division
	 *     Primary returns Division
	 *     Parenthesis returns Division
	 *
	 * Constraint:
	 *     (left=DivisionExp_Division_1_1 right=MultiplicationExp)
	 */
	protected void sequence_DivisionExp(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivisionExpAccess().getDivisionLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivisionExpAccess().getRightMultiplicationExpParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Let
	 *     SubtractionExp returns Let
	 *     SubtractionExp.Subtractio_1_1 returns Let
	 *     AdditionExp returns Let
	 *     AdditionExp.Addition_1_1 returns Let
	 *     DivisionExp returns Let
	 *     DivisionExp.Division_1_1 returns Let
	 *     MultiplicationExp returns Let
	 *     MultiplicationExp.Multiplication_1_1 returns Let
	 *     Primary returns Let
	 *     Parenthesis returns Let
	 *     Let returns Let
	 *
	 * Constraint:
	 *     (name=ID assigment=Primary exp=Exp)
	 */
	protected void sequence_Let(ISerializationContext context, Let semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.LET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.LET__NAME));
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.LET__ASSIGMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.LET__ASSIGMENT));
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.LET__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.LET__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetAccess().getAssigmentPrimaryParserRuleCall_3_0(), semanticObject.getAssigment());
		feeder.accept(grammarAccess.getLetAccess().getExpExpParserRuleCall_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathExp returns MathExp
	 *
	 * Constraint:
	 *     (name=ID exp=SubtractionExp)
	 */
	protected void sequence_MathExp(ISerializationContext context, MathExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.MATH_EXP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.MATH_EXP__NAME));
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.MATH_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.MATH_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathExpAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMathExpAccess().getExpSubtractionExpParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Multiplication
	 *     SubtractionExp returns Multiplication
	 *     SubtractionExp.Subtractio_1_1 returns Multiplication
	 *     AdditionExp returns Multiplication
	 *     AdditionExp.Addition_1_1 returns Multiplication
	 *     DivisionExp returns Multiplication
	 *     DivisionExp.Division_1_1 returns Multiplication
	 *     MultiplicationExp returns Multiplication
	 *     MultiplicationExp.Multiplication_1_1 returns Multiplication
	 *     Primary returns Multiplication
	 *     Parenthesis returns Multiplication
	 *
	 * Constraint:
	 *     (left=MultiplicationExp_Multiplication_1_1 right=Primary)
	 */
	protected void sequence_MultiplicationExp(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationExpAccess().getMultiplicationLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationExpAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Number returns Expression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Number(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Expression
	 *     SubtractionExp returns Expression
	 *     SubtractionExp.Subtractio_1_1 returns Expression
	 *     AdditionExp returns Expression
	 *     AdditionExp.Addition_1_1 returns Expression
	 *     DivisionExp returns Expression
	 *     DivisionExp.Division_1_1 returns Expression
	 *     MultiplicationExp returns Expression
	 *     MultiplicationExp.Multiplication_1_1 returns Expression
	 *     Primary returns Expression
	 *     Parenthesis returns Expression
	 *
	 * Constraint:
	 *     (value=INT | ref=[MathExp|ID])
	 */
	protected void sequence_Number_VariableUse(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Subtractio
	 *     SubtractionExp returns Subtractio
	 *     SubtractionExp.Subtractio_1_1 returns Subtractio
	 *     AdditionExp returns Subtractio
	 *     AdditionExp.Addition_1_1 returns Subtractio
	 *     DivisionExp returns Subtractio
	 *     DivisionExp.Division_1_1 returns Subtractio
	 *     MultiplicationExp returns Subtractio
	 *     MultiplicationExp.Multiplication_1_1 returns Subtractio
	 *     Primary returns Subtractio
	 *     Parenthesis returns Subtractio
	 *
	 * Constraint:
	 *     (left=SubtractionExp_Subtractio_1_1 right=AdditionExp)
	 */
	protected void sequence_SubtractionExp(ISerializationContext context, Subtractio semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.SUBTRACTIO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.SUBTRACTIO__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.SUBTRACTIO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.SUBTRACTIO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubtractionExpAccess().getSubtractioLeftAction_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubtractionExpAccess().getRightAdditionExpParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableUse returns Expression
	 *
	 * Constraint:
	 *     ref=[MathExp|ID]
	 */
	protected void sequence_VariableUse(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathPackage.Literals.EXPRESSION__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathPackage.Literals.EXPRESSION__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableUseAccess().getRefMathExpIDTerminalRuleCall_0_1(), semanticObject.eGet(MathPackage.Literals.EXPRESSION__REF, false));
		feeder.finish();
	}
	
	
}
